# タスク関連 統合テストシナリオ

## 概要
このテストシナリオでは、タスク関連APIの統合テストケースを定義します。個別のAPIエンドポイントではなく、一連のAPIの呼び出しフローとデータの整合性を検証します。

## 前提条件
- テストユーザーが存在している
- ヘルパーユーザーが存在している
- 管理者ユーザーが存在している
- ユーザー・ヘルパーの割り当て関係が設定されている

## テストシナリオ

### シナリオ1: タスク完全ライフサイクル（ユーザー作成→ヘルパー更新→完了）

**ステップ1: ユーザーがタスクを作成**
- リクエスト: `POST /api/v1/tasks` (ユーザーアクセストークン)
- レスポンス: 作成されたタスク情報 (id: 123, status: "requested")

**ステップ2: ユーザーが自分のタスク一覧を確認**
- リクエスト: `GET /api/v1/users/{user_id}/tasks` (ユーザーアクセストークン)
- レスポンス: タスク一覧に新しいタスクが含まれている

**ステップ3: ヘルパーが担当ユーザーのタスク一覧を確認**
- リクエスト: `GET /api/v1/users/{user_id}/tasks` (ヘルパーアクセストークン)
- レスポンス: ユーザーのタスク一覧が表示される

**ステップ4: ヘルパーがタスクを進行中に更新**
- リクエスト: `PUT /api/v1/tasks/123/status` (ヘルパーアクセストークン)
  - リクエストボディ: `{"status": "in_progress"}`
- レスポンス: 更新されたタスク情報 (status: "in_progress")

**ステップ5: ユーザーがタスク詳細を確認**
- リクエスト: `GET /api/v1/tasks/123` (ユーザーアクセストークン)
- レスポンス: タスク情報 (status: "in_progress")

**ステップ6: ヘルパーがタスクを完了に更新**
- リクエスト: `PUT /api/v1/tasks/123/status` (ヘルパーアクセストークン)
  - リクエストボディ: `{"status": "completed"}`
- レスポンス: 更新されたタスク情報 (status: "completed")

**ステップ7: ユーザーが完了したタスク一覧を確認**
- リクエスト: `GET /api/v1/users/{user_id}/tasks?status=completed` (ユーザーアクセストークン)
- レスポンス: 完了済みタスクの一覧に新しいタスクが含まれている

**期待結果**:
- すべてのステップが正常に完了
- 各ステップでのレスポンスが想定通り
- タスクの状態変化が適切に反映される

### シナリオ2: タスク作成と編集（ユーザーによる操作）

**ステップ1: ユーザーがタスクを作成**
- リクエスト: `POST /api/v1/tasks` (ユーザーアクセストークン)
  - リクエストボディ: タスク情報（基本項目）
- レスポンス: 作成されたタスク情報 (id: 124)

**ステップ2: ユーザーがタスク情報を更新**
- リクエスト: `PUT /api/v1/tasks/124` (ユーザーアクセストークン)
  - リクエストボディ: 更新されたタスク情報
- レスポンス: 更新されたタスク情報

**ステップ3: ユーザーがタスク詳細を確認**
- リクエスト: `GET /api/v1/tasks/124` (ユーザーアクセストークン)
- レスポンス: 更新済みのタスク情報

**ステップ4: ユーザーがタスクをキャンセル**
- リクエスト: `PUT /api/v1/tasks/124/status` (ユーザーアクセストークン)
  - リクエストボディ: `{"status": "cancelled"}`
- レスポンス: 更新されたタスク情報 (status: "cancelled")

**期待結果**:
- すべてのステップが正常に完了
- タスク情報の更新が反映される
- キャンセル操作が正常に実行される

### シナリオ3: 管理者のタスク管理

**ステップ1: 管理者がユーザーのタスク一覧を取得**
- リクエスト: `GET /api/v1/users/{user_id}/tasks` (管理者アクセストークン)
- レスポンス: ユーザーのタスク一覧

**ステップ2: 管理者がタスク詳細を確認**
- リクエスト: `GET /api/v1/tasks/{task_id}` (管理者アクセストークン)
- レスポンス: タスク詳細情報

**ステップ3: 管理者がタスク情報を更新**
- リクエスト: `PUT /api/v1/tasks/{task_id}` (管理者アクセストークン)
  - リクエストボディ: 更新されたタスク情報
- レスポンス: 更新されたタスク情報

**ステップ4: 管理者がタスク状態を更新**
- リクエスト: `PUT /api/v1/tasks/{task_id}/status` (管理者アクセストークン)
  - リクエストボディ: `{"status": "in_progress"}`
- レスポンス: 更新されたタスク情報

**ステップ5: 管理者がタスクを削除**
- リクエスト: `DELETE /api/v1/tasks/{task_id}` (管理者アクセストークン)
- レスポンス: 削除成功メッセージ

**期待結果**:
- すべてのステップが正常に完了
- 管理者権限による操作が正常に実行される
- 削除したタスクがデータベースから削除される

### シナリオ4: 複数タスクの作成と一括操作

**ステップ1: ユーザーが複数のタスクを作成（3件）**
- 3回の `POST /api/v1/tasks` リクエスト (ユーザーアクセストークン)
- レスポンス: 作成されたタスク情報 (id: 125, 126, 127)

**ステップ2: ユーザーがタスク一覧をフィルタリング**
- リクエスト: `GET /api/v1/users/{user_id}/tasks?category=掃除` (ユーザーアクセストークン)
- レスポンス: カテゴリが "掃除" のタスクのみの一覧

**ステップ3: ヘルパーが優先度でフィルタリング**
- リクエスト: `GET /api/v1/users/{user_id}/tasks?priority=5` (ヘルパーアクセストークン)
- レスポンス: 優先度が 5 のタスクのみの一覧

**ステップ4: 複数の更新操作（ユーザーとヘルパーが交互に）**
- ユーザーがタスク更新: `PUT /api/v1/tasks/125` (ユーザーアクセストークン)
- ヘルパーがステータス更新: `PUT /api/v1/tasks/125/status` (ヘルパーアクセストークン)
- ユーザーがタスク詳細確認: `GET /api/v1/tasks/125` (ユーザーアクセストークン)

**期待結果**:
- すべてのステップが正常に完了
- フィルタリングが正常に機能する
- 複数のタスクが作成され、個別に操作できる
- 異なるユーザーロールからの操作が正常に機能する

### シナリオ5: エラー処理とエッジケース

**ケース1: 存在しないタスクへのアクセス**
- リクエスト: `GET /api/v1/tasks/9999` (ユーザーアクセストークン)
- 期待結果: 404 Not Found エラー

**ケース2: 権限のないタスクの更新**
- リクエスト: `PUT /api/v1/tasks/{他のユーザーのタスクID}` (ユーザーアクセストークン)
- 期待結果: 403 Forbidden エラー

**ケース3: 無効なステータス値**
- リクエスト: `PUT /api/v1/tasks/{task_id}/status` (ヘルパーアクセストークン)
  - リクエストボディ: `{"status": "invalid_status"}`
- 期待結果: 422 Unprocessable Entity エラー

**ケース4: 二重削除**
- リクエスト1: `DELETE /api/v1/tasks/{task_id}` (ユーザーアクセストークン)
- リクエスト2: 同じタスクIDに対する再度の削除リクエスト
- 期待結果: 最初は成功、二回目は404 Not Found エラー

**期待結果**:
- すべてのエラーケースが適切に処理される
- エラーメッセージが明確で具体的
- エラー後のシステム状態が一貫している

## モック設定
- データベースに複数のユーザー、ヘルパー、タスクのレコードを事前に用意
- ユーザー・ヘルパー割り当て関係を設定
- 異なるステータス、優先度、カテゴリ、予定日のタスクを含める

## 検証項目
- 一連のAPI呼び出しフローが正常に完了すること
- データの整合性が保たれること
- ステータス遷移が適切に処理されること
- 異なるユーザーロール間の相互作用が正しく動作すること
- エラー処理とリカバリーが適切に機能すること
